# GoTunnel - 一个安全、可靠的TCP反向隧道工具

![Go Version](https://img.shields.io/badge/go-1.18%2B-blue.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)

GoTunnel 是一个使用 Go 语言编写的高性能TCP反向隧道。它允许你将位于内网或防火墙后的本地服务，安全地暴露到公网服务器上。它非常适合于临时演示、远程开发、或者将家庭网络中的服务（如NAS、网站）暴露给外部访问等场景。

## 核心特性

*   **🔒 双层安全机制**:
    1.  **TLS 1.2+ 加密隧道**: 客户端和服务端之间的所有通信都通过标准的TLS进行加密，从根本上防止了数据窃听和篡改。
    2.  **预共享密钥 (PSK) 认证**: 在TLS加密层之上，增加了一层应用级认证。只有持有正确密钥的客户端才能成功建立隧道，有效防止未授权的客户端连接到服务端。

*   **✨ 自动化证书管理**:
    *   服务端首次启动时会自动生成自签名的CA证书和服务器证书，无需手动配置OpenSSL。
    *   服务端启动时会直接在控制台打印出`ca.crt`的内容，方便客户端用户直接复制使用，极大简化了部署流程。

*   **🚀 高性能连接复用**:
    *   基于 [smux](https://github.com/xtaci/smux) 实现，在单一的TCP连接上复用多个数据流。这大大减少了TCP握手的开销，降低了延迟，并能高效地处理大量并发的短连接。

*   **🔄 健壮的客户端自动重连**:
    *   客户端内置了带有**指数退避**和**抖动**的自动重连机制。当与服务端的连接意外断开时，客户端会持续尝试重连，直到成功为止，确保了隧道的长期稳定性。

*   **💧 优雅的资源管理**:
    *   服务端能智能地监控客户端会话的存活状态。一旦客户端断开连接，服务端会立即关闭并释放其占用的公网监听端口，防止资源泄露。

*   **🔌 灵活的命令行接口**:
    *   采用标准的子命令模式 (`server` 和 `client`)，参数清晰，易于理解和使用。

## 工作原理

GoTunnel 的工作流程非常直接，但却十分有效：

1.  **服务端启动**: 在一台拥有公网IP的服务器上运行 `gotunnel server`。它会监听一个指定的端口（如 `:7000`），等待客户端的连接。如果这是首次运行，它会自动在 `certs/` 目录下创建所需的CA和服务器证书。
2.  **客户端连接**: 在内网的机器上运行 `gotunnel client`。客户端会使用你提供的 `ca.crt` 文件，与服务端建立一个TLS加密连接。
3.  **双重认证**:
    *   TLS层面上，客户端会验证服务端的证书是否由给定的 `ca.crt` 签署，且证书名称是否为 `gotunnel.internal`（这是一个内部固定的名称，解耦了证书与服务器IP）。
    *   认证成功后，客户端会立即发送预共享密钥 (`-secret`) 给服务端进行应用层认证。
4.  **隧道建立**: 服务端验证密钥无误后，隧道正式建立。客户端会立即通过这个隧道发送一个控制消息，请求服务端监听一个公网端口（如 `:8080`）。
5.  **流量转发**:
    *   服务端在公网 `:8080` 端口上开始监听。
    *   当一个外部用户连接到 `公网服务器IP:8080` 时，服务端会接受这个连接。
    *   服务端通过 `smux` 隧道向客户端发起一个新的数据流。
    *   客户端收到新数据流后，会与本地服务（如 `127.0.0.1:80`）建立一个连接。
    *   最终，GoTunnel 在 `外部用户 <-> 服务端` 和 `客户端 <-> 本地服务` 之间双向转发所有数据。



## 安装

你需要 Go 1.18 或更高版本的编译环境。

```bash
# 克隆仓库 (或者直接保存代码为 main.go)
# git clone https://your-repo/gotunnel.git
# cd gotunnel

# 编译
go build -o gotunnel .
```

编译后，你会在当前目录下得到一个名为 `gotunnel` 的可执行文件。

## 使用方法

GoTunnel 分为 `server` 和 `client` 两种模式。

### 1. 服务端模式 (在公网服务器上运行)

启动服务端非常简单。你只需要指定一个共享密钥。

```bash
# 语法: ./gotunnel server -secret "你的强密码" [-listen <端口>]
./gotunnel server -secret "s3cr3t-p@ssw0rd-f0r-tunn3l" -listen 7000
```

*   `-secret`: **必需**。用于认证客户端的共享密钥。
*   `-listen`: *可选*。服务端监听客户端连接的端口，默认为 `7000`。

首次启动时，你会看到类似下面的输出：

```
2023/10/27 10:30:01.123456 未找到 CA 证书，将生成新的 CA 和服务器证书...
2023/10/27 10:30:01.567890 新证书生成成功！
2023/10/27 10:30:01.567891 服务端模式：隧道监听于 :7000

======================= SERVER IS RUNNING (SECURE) =======================
共享密钥 (Secret): s3cr3t-p@ssw0rd-f0r-tunn3l
监听地址 (Listening on): :7000

请在客户端机器上创建一个 ca.crt 文件, 并将以下内容复制进去:
-----BEGIN CERTIFICATE-----
MIIBqDCCASKgAwIBAgIQTjZgVwS9k3D3H/tEdp4J/DAKBggqhkjOPQQDAjAYMRYw
FAYDVQQDEw1Hb1R1bm5lbCBDQTAeFw0yMzEwMjcwMjMwMDFaFw0zMzEwMjQwMjMw
MDFaMBgxFjAUBgDVQQDEw1Hb1R1bm5lbCBDQTCCASwGCSqGSIb3DQEBAQANIAAw
ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDA...
-----END CERTIFICATE-----

然后使用类似如下命令连接 (请将 <server_ip> 替换为服务器的真实公网IP):
./gotunnel client -server <server_ip>:7000 -secret "s3cr3t-p@ssw0rd-f0r-tunn3l" -ca ./ca.crt -remote-port 8080 -local-target 127.0.0.1:80
==========================================================================
```

**操作步骤**:

1.  运行上面的命令。
2.  **关键**: 复制从 `-----BEGIN CERTIFICATE-----` 到 `-----END CERTIFICATE-----` 的所有内容。
3.  在你的客户端机器上，创建一个名为 `ca.crt` 的文件，并将复制的内容粘贴进去。

### 2. 客户端模式 (在内网机器上运行)

假设你的公网服务器IP是 `1.2.3.4`，并且你希望将本地运行在 `127.0.0.1:3000` 的一个Web服务通过服务器的 `8080` 端口暴露出去。

首先，确保你已经按照上一步创建了 `ca.crt` 文件。

然后运行以下命令：

```bash
# 语法: ./gotunnel client -server <IP:端口> -secret "密钥" -ca <ca文件路径> -remote-port <公网端口> -local-target <本地服务地址>
./gotunnel client \
    -server 1.2.3.4:7000 \
    -secret "s3cr3t-p@ssw0rd-f0r-tunn3l" \
    -ca ./ca.crt \
    -remote-port 8080 \
    -local-target 127.0.0.1:3000
```
*   `-server`: **必需**。服务端的公网地址和监听端口。
*   `-secret`: **必需**。必须与服务端设置的密钥完全一致。
*   `-ca`: *可选*。CA证书的路径，默认为 `./ca.crt`。
*   `-remote-port`: *可选*。你希望在公网服务器上监听的端口，默认为 `8080`。
*   `-local-target`: *可选*。你要暴露的内网服务的地址，默认为 `127.0.0.1:80`。
*   `-max-retry-interval`: *可选*。自动重连的最大间隔，默认为 `60s`。

客户端成功连接后，你会看到类似日志：
```
2023/10/27 10:35:01.123456 正在尝试建立到服务端 1.2.3.4:7000 的 TLS 连接...
2023/10/27 10:35:01.678901 TLS 连接成功，正在进行应用层 PSK 认证...
2023/10/27 10:35:01.789012 PSK 认证成功！隧道已建立。
2023/10/27 10:35:01.789123 正在打开控制流以发送端口转发请求...
2023/10/27 10:35:01.890123 服务端成功响应: 成功在 [::]:8080 上监听, 准备转发流量
2023/10/27 10:35:01.890234 控制指令发送成功，开始监听并转发流量...
```
此时，任何人访问 `http://1.2.3.4:8080`，其流量都会被安全地转发到你内网机器的 `127.0.0.1:3000` 服务上。

## 技术设计剖析

*   **固定的证书名称 (`gotunnel.internal`)**: 服务端生成的证书，其 `CommonName` 被硬编码为 `gotunnel.internal`。客户端在进行TLS握手时，会使用 `tls.Config` 中的 `ServerName` 字段来指定它期望验证的服务器名称。这巧妙地将TLS身份验证与服务器的DNS名称或IP地址解耦。无论你的服务器IP如何变化，只要客户端使用由同一CA签发的证书，验证就能通过。

*   **服务端监听器生命周期管理**: ใน `handleClientSession` 函数中，有一个专门的 "watcher" goroutine。它使用 `time.NewTicker` 定期（每秒）检查 `session.IsClosed()`。一旦发现 smux 会话关闭（意味着客户端已断开连接），它会立即调用 `publicListener.Close()`。这会使主循环中阻塞的 `publicListener.Accept()` 返回一个错误，从而导致整个会话处理函数干净地退出，并释放公网端口。这是确保服务端不会因客户端异常断开而产生资源泄露的关键设计。

## 许可证

本项目基于 [MIT License](LICENSE) 授权。
